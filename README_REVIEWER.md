В задании на ETL предлагалось выложить результат в ./postgres_to_es. Я решил, что быстрее 
и удобнее реализовать ETL в качестве приложения Django. Поэтому ищите решение в 
./movies_admin/etl :)

# О реализации
ETL реализован как приложение Django. Состояние ETL хранится в поле `indexed_at` 
модели `movies.models.FilmWork`. Такой способ хранения состояния жёстко связан с Django, 
но позволяет малой кровью гарантировать, что никакой объект не будет пропущен.

Мы обсуждали в Slack со студентами и наставником другие варианты - например,
хранилище в Redis, с которым предлагалось поработать в тренажёре.
Признали, что с ним либо будут подводные камни, либо задача окажется сложнее, чем
нужно в рамках спринта.
Среди подводных камней с Redis:
- Возможная потеря данных приведёт к необходимости полной реиндексации.
- Добавляется дополнительный сервис, от которого зависит ETL.
- Можно хранить состояние в виде одного значения (например, индексировано всё,
что обновлено не позднее указанной в состоянии даты). Объекты для реиндексации 
запрашивать в базе, сортируя по дате обновления `modified` начиная со старых. Выбирать первые
`n` записей. Тогда будут проблемы с загрузкой пачками, если есть больше `n` записей с
одинаковой датой (созданных с помощью bulk_create, или в результате миграции при 
появлении поля `modified`). Придётся дополнительно отслеживать количество индексированных 
фильмов с текущей датой.
- Можно хранить в Redis для каждого объекта дату последней индексации. Получится то
же самое, что и в данной реализации, только придётся сделать ещё и мини-ETL состояния
в Redis :)


# Запуск сервиса
Советую запускать сервис в dev среде. Там есть относительно подробные логи.
Для этого выполните:
```commandline
docker compose up --build
```
Если хотите production, то:
```commandline
docker compose -f docker-compose.prod.yml up --build
```
Подключитесь к контейнеру `movies_admin`. 
Загрузите fixture с основной базой, чтобы было на чём тестировать:
```commandline
python manage.py loaddata movies.json
```
Для инициализации ElasticSearch выполните команду:
```commandline
python manage.py init_es
``` 
Команда пересоздаёт индекс `movies`, т.е. если индекс создан - то он будет очищен и создан заново.
Кроме того, в базе сбрасывается информация об индексации.

Запустите ETL:
```commandline
python manage.py start_etl
```

Измените какую-либо модель (например, название жанра) в админке и повторите ETL.
Переиндексируется лишь то, что поменялось с прошлого раза!

# Списко изменений после ревью №1
1. Заменил `StringAgg` на `ArrayAgg` при аннотации жанров и участников кинопроизведения.
Действительно, так аккуратнее.
2. Использовал `pydantic` для валидации данных. После консультации с сокурсниками и наставником предпочёл,
чтобы ETL процесс прерывался при получении инвалидных данных - но прерывался с явным указанием ошибки.
В таком случае, разработчик или администратор БД должны будут устранить проблему с данными перед возобновленем ETL.
Зато не будет неявных застреваний в цикле при накоплении ошибок > размера пачки, или некорректной записи в индекс.
3. Логи скорректированны - понижен уровень важности для написанных ранее, добавлены логи на случай получения некорректных
данных.